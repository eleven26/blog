---
title: C++ 模板的显式具体化
date: 2020-04-20 20:27:00
tags: [C++]
---

C++ 没有办法限制类型参数的范围，我们可以使用任意一种类型来实例化模板。但是模板中的语句（函数体或者类体）不一定就能适应所有的类型，可能会有个别的类型没有意义，或者会导致语法错误。

例如有下面的函数模板，它用来获取两个变量中较大的一个：

```
template<class T> const T& Max(cosnt T& a, const T& b) {
    return a > b ? a : b;
}
```

请读者注意 `a > b` 这条语句，`>` 能够用来比较 int、float、char 等基本类型数据的大小，但是却不能用来比较结构体变量、对象以及数组的大小，因为我们并没有针对结构体、类和数组重载 `>`。

另外，该函数模板虽然可以用于指针，但比较的是地址大小，而不是指针指向的数据，所以也没有现实的意义。

除了 `>`，`+` `-` `*` `/` 等运算符也只能用于基本类型，不能用于结构体、类、数组等复杂类型。总之，编写的函数模板很可能无法处理某些类型，我们必须对这些类型进行单独处理。

模板是一种泛型技术，它能接受的类型是宽泛的、没有限制的，并且对这些类型使用的算法都是一样的（函数体或类体一样）。但是现在我们希望改变这种 "游戏规则"，让模板能够针对某种具体的类型使用不同的算法（函数体或类体不同），这在 C++ 中是可以做到的，这种技术称为模板的显式具体化（Explicit Specialization）。

函数模板和类模板都可以显式具体化，下面我们线讲解函数模板的显式具体化，再讲解类模板的显式具体化。


## 函数模板的显式具体化

在讲解函数模板的显式具体化语法之前，我们先来看一个显式具体化的例子：


