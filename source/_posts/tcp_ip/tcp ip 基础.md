---
title: TCP/IP 基础
date: 2020-02-16 20:47:30
tags: [TCP/IP]
---


## 计算机网络体系结构分层

* OSI 七层模型

应用层

表示层

回话层

传输层

网络层

数据链路层

物理层

OSI 参考模型中定义了每一层的 "作用"，定义每一层作用的是 "协议"，"协议" 是约定，其具体内容为 "规范"，我们日常所使用的就是遵循各个协议具体 "规范" 的产品和通信手段。


* TCP/IP 概念层模型

应用层

传输层

网络层

链路层

OSI 参考模型注重 "通信协议必要的功能是什么"，而 TCP/IP 则更强调 "在计算机上实现协议应该开发哪种程序"。


## TCP/IP 基础

1. TCP/IP 的具体含义

从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很懂情况下，它只是利用 IP 进行通信时
必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。
他们与 TCP/IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。

互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网协议。

应用协议：HTTP、SMTP、FTP、TELNET、SNMP

传输协议：TCP、UDP

路由控制协议：RIP、OSPF、BGP

网际协议：IP、ICMP、ARP


2. 数据包

包、帧、数据包、段、消息

以上 5 个术语都用来表述数据的单位，大致区分如下：

* 包可以说是全能性术语

* 帧用于表示数据链路层中包的单位

* 数据包是 IP 和 UDP 等网络层以上的分层包中的单位

* 段则表示 TCP 数据流中的信息

* 消息是指应用协议中数据的单位。

每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。
通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。

网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。
在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。


3. 数据处理流程

下图以用户 a 向用户 b 发送邮件的例子：

![x](/images/tcp_ip/1.jpeg)


* 应用程序处理

首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；

编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层的功能。

* TCP 模块的处理

TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。

为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。

* IP 模块的处理

IP  将 TCP 传过来的 TCP 首部和 TCP 数据结合起来当作自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。

IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。

* 网络接口（以太网驱动）的处理

从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。

* 网络接口（以太网驱动）的处理

主机接收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。

如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP。

* IP 模块的处理

IP 模块接收到数据后也做类似的处理。从包首部中判断此 IP 地址地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。

另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。

* TCP 模块的处理

在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别地应用程序。

* 应用程序的处理

接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。


## 传输层中的 TCP 和 UDP

TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。

* TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。
TCP 为提供可靠性传输，实现 "顺序控制" 或 "重发控制" 机制。此外还具备 "流控制（流量控制）"、"拥塞控制"、提高网络利用率等众多功能。

* UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。
因此，应用有时会根据自己的需要进行重发处理。

* TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在另一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。


1. 端口号

数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。
在传输层也有类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被成为程序地址。


1.1 根据端口号识别应用

一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。


![x](/images/tcp_ip/2.jpeg)


1.2 通过 IP 地址、端口号、协议号进行通信识别

* 仅凭目标端口号识别某一个通信是远远不够的

![x](/images/tcp_ip/3.jpeg)

![x](/images/tcp_ip/4.jpeg)

① 和 ② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是 80。这里可以根据源端口号加以区分。

③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。

此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。


1.3 端口号的确定

* 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。
这些端口号被成为知名端口号，分布在 0～1023 之间；除知名端口号外，还有一些端口号被正式注册，它们分布在 1024～49151 之间，不过这些端口号可用于任何通信用途。

* 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口范围在 49152~65535 之间。

1.4 端口号与协议

* 端口号由其使用的传输层协议决定。因此，不同的传输层协议使用相同的端口号。

* 此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。


2. UDP

* UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。

* 并且它是将应用程序发来的数据在接收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥堵行为。

* 此外，传输途中出现丢包，UDP 也不负责重发。

* 甚至当包的到达顺序出现乱序时也没有纠正的功能。

* 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。

* UDP 常用于以下几个方面：1. 包总量较少的通信（DNS、SNMP等）；2. 视频、音频等多媒体通信（即时通信）；3. 限定于 LAN 等特定网络中的应用通信；4. 广播通信（广播、多播）


3. TCP

* TCP 与 UDP 的区别相当大。它充分地实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。

* 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。

* 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（主要通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。


3.1 三次握手（重点）

* TCP 提供面向有连接的通信控制。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。

* 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在 socket 编程中，这一过程由客户端执行 connect 来触发。

下面来看看三次握手的流程图：

![x](/images/tcp_ip/5.jpeg)


* 第一次握手：客户端将标志位 SYN 置为 1，随机产生一个值 seq = J，并将该数据包发送给服务器端，客户端进入 SYN_SENT 状态，等待服务器端确认。

* 第二次握手：服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务器端将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，
并将该数据包发送给客户端以确认连接请求，服务器端进入 SYN_RECVD 状态。

* 第三次握手：客户端收到确认后，检查 ack 是否为 J+1，ACK 是否为 1，如果正确则将标志位 ACNK 置为 1，ack=K+1，并将该数据包发送给服务器端，服务器端
检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。


3.2 四次挥手（重点）

* 四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。

* 由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，
即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

下面来看看四次挥手的流程图：

![x](/images/tcp_ip/6.jpeg)


* 中断连接端可以是客户端，也可以是服务器端

* 第一次挥手：客户端发送一个 FIN=M，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。意思是说 "我客户端没有数据要发给你了"，但是如果你服务器端
还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。

* 第二次挥手：服务器端收到 FIN 后，先发送 ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好， 请继续你等我的消息。这个时候客户端就进入 FIN_WAIT_2 状态，继续等待服务器端的 FIN 报文。

* 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送 FIN=N 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。

* 第四次挥手：客户端收到 FIN=N 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。
服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次挥手。

上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。

具体流程如下图：

![x](/images/tcp_ip/7.jpeg)


3.3 通过序列号与确认应答提高可靠性

* 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后等待对端的确认应答。
如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。

* 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够达到对端，实现可靠传输。

* 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。

* 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。

* 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。

* 序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收到的序列号作为
确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。


![x](/images/tcp_ip/8.jpeg)


3.4 重发超时的确定

* 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证 "确认应答一定能在这个时间内返回"。

* TCP 要求不论处在何种网络环境下都要提高通信性能，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间以及偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。

* 在 BSD 的 Unix 以及 Windows 系统中，超时都以 0.5 秒为单位进行控制，因此重发超时都是 0.5 秒的整数倍。不过，最初其重发超时的默认值一般设置为 6 秒左右。

* 数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以 2 倍、4 倍的指数函数延长。

* 此外，数据也不会被反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接，并且通知应用通信异常强行终止。


3.5 以段为单位发送数据

* 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为 "最大报文段长度"（MSS）。最理想的情况是，最大报文长度正好是 IP 中不会被分片处理的数据长度。

* TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。

* MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。


3.6 利用窗口控制提高速度

* TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。

* 为了解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待应答，而是继续发送。如下图所示：

![x](/images/tcp_ip/9.jpeg)

* 窗口控制

* 窗口大小就是指无需等待确认应答可以继续发送数据的值。上图中窗口大小为 4 个段。这个机制实现了使用最大量的缓冲区，同时对多个段同时进行确认应答的功能。


3.7 滑动窗口控制

![x](/images/tcp_ip/10.jpeg)

* 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。
为此，发送端主机需要设置缓存保留这些被重传的数据，直到收到他们的确认应答。

* 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。

* 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的未知。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口机制。


3.8 窗口控制中的重发控制

在使用窗口控制中，出现丢包一般分为两种情况：

* 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：

![x](/images/tcp_ip/11.jpeg)

* 某个报文段丢失的情况。接收主机如果收到一个自己应该收到的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一段报文丢失后，发送端会一直收到
序号为 1001 的确认应答，因此，在窗口比较大，又出现报文丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续 3 次收到同一个确认应答，
就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发机制。

![x](/images/tcp_ip/12.jpeg)



## 网络层中的 IP 协议

* IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层 -- 网络层。网络层的主要作用是 "实现终端节点之间的通信"。这种终端节点之间的通信也叫 "点对点通信"。

* 网络的下一层 -- 数据链路层的主要作用是在互连同一数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，
即使是在不同的数据链路上也能实现两端节点之间的数据包传输。

* IP 大致分为三大作用模块，它们是 IP寻址、路由（最终节点为止的转发）以及 IP 分包与组包。


1. IP 地址

1.1 IP 地址概述

* 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。

* 作为网络层的 IP，也有这种地址信息，一般叫做 IP 地址。IP 地址用于在 "连接到网络中的所有主机中识别出进行通信的目标地址"。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。

* 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。

* IP地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以
每 8 位为一组，分为 4 组，每组以 "." 隔开，再将每组数转换成十进制数。如下：

![x](/images/tcp_ip/13.jpeg)



1.2 IP 地址由网络和主机两部分标识组成


* 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内的主机必须有相同的网络地址。IP 地址的 "主机标识"
则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。

![x](/images/tcp_ip/14.jpeg)


* 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。

![x](/images/tcp_ip/15.jpeg)


1.3 IP 地址的分类

* IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。

* A 类 IP 地址是首位以 "0" 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。
A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16777214 个。

* B 类 IP 地址是前两位 "10" 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。
B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65534 个。

* C 类 IP 地址是前三位为 "110" 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。
C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。

* D 类 IP地址是前四位为 "1110" 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。
D 类地址没有主机标识，常用于多播。

* 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或
IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段
最多只能有 254 个主机地址的原因。


1.4 广播地址

* 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。

* 广播分为本地广播和直接广播。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。

