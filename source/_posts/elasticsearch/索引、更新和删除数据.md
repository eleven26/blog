---
title: 索引、更新和删除数据
date: 2019-12-09 21:47:00
tags: [ElasticSearch]
---

## 本文主要内容

* 使用映射类型来定义同一个索引中的多种文档类型

* 可以在映射中使用的不同字段类型

* 使用预定义的字段及其选项

本文内容是关于如何在 ElasticSearch 中存入和获取数据，并且维护这些数据：索引、更新和删除文档。
我们知道，ElasticSearch 是基于文档的，而文档是由字段和其值组成的，这些使得文档是自我完备的，就好像一张数据表中有行和列一样。
在第 2 章中，你看到可以通过 Elasticsearch 的 REST API 来索引一篇文档。这里，我们将观察文档中的字段以及它们所包含的内容，
来深入理解索引过程的细节。例如，当索引一篇这样的文档时：

```
{"name": "Elasticsearch Denver"}
```

由于 Elasticsearch Denver 是一个字符串，所以 name 字段是字符串类型。其他的字段可能是数值型、布尔型等。本文将介绍以下 3 种类型的字段。

* 核心 - 这些字段包括字符串和数值型

* 数组和多元字段 - 这些字段在某个字段中存储相同核心类型的多个值。例如，tags 字段可以拥有多个标签

* 预定义 - 这些字段包括 _ttl(time to live) 和 _timestamp。

可以认为这些字段是元数据，Elasticsearch 会自动地管理它们，提供更多额外地功能。
举例来说，可以配置 Elasticsearch，让其自动地将新数据加入文档集合（如时间戳），或者可以使用 _ttl 字段让过期的文档自动删除。

我们已经知道了文档中可以有的字段类型，以及如何索引这些字段，现在我们将看看如何更新已经存在的文档。鉴于存储数据的方式，当
Elasticsearch 更新现存文档的时候，它会检索出这篇文档，然后按照需求进行修改。然后 Elasticsearch 再次索引更改后的文档，并删除
相应的旧文档。这些更新操作会引起并发问题，你将看到如何通过文档版本自动地解决这些问题。
你将看到删除文档地不同方法，某些方法比其他的运行速度更快。Elasticsearch 索引使用的主要程序库是 Apache Lucene，
Lucene 在磁盘上存储数据的特殊方法又导致了这些差异。


## 使用映射来定义各种文档

每篇文档属于一种类型，而每种类型属于一个索引。从数据的逻辑划分来看，可以认为索引是数据库，而类型是数据库中的表。
例如，第 2 章介绍了聚会网站的分组和活动使用了不同的类型，因为它们拥有不同的数据结构。注意一下，如果这个站点也有博客，
可能要将博客帖子和评论保存在分开的索引中，因为它们是完全不同的数据集。

类型包含了映射中每个字段的定义。映射包括了该类型的文档中可能出现的所有字段，并告诉 Elasticsearch 如何索引一篇文档的多个字段。
例如，如果一个字段包含日期，可以定义哪种日期格式是可以接受的。

* 类型只提供逻辑上的分离

> 在 Elasticsearch 中，不同类型的文档没有物理上的分离。在同一个 Elasticsearch 索引中的所有文档，无论何种类型，
> 都是存储在属于相同分片的同一组文件中。一份分片就是一个 Lucene 的索引，类型的名称是 Lucene 索引中一个字段，所有
> 映射的所有字段都是 Lucene 索引中的字段。

> 索引的概念是针对 Elasticsearch 的一层抽象，但不属于 Lucene。这使得你可以轻松地在同一个索引中拥有不同类型的文档。
> Elasticsearch 负责分离这些文档，例如，在某个类型中搜索时，Elasticsearch 会过滤出属于那个类型的文档。

> 这种方法产生了一个问题：当多个类型中出现同样的字段名称时，两个同名的字段应该有同样的设置。
> 否则，Elasticsearch 将很难辨别你所指的是两个字段中的哪一个。最后，两个字段都是属于同一个 Lucene 索引。
> 例如，如果在分组和活动文档中都有一个 name 字段，两个都应该是字符串类型，不能一个是字符串而另一个是整数类型。
> 在实际使用中，这种问题很少见，但是还是需要记住这一点，防止意外发生。

![3-1](/images/es/1.png)

在上图中，group 和 event 存储在不同的类型中。然后应用程序可以在特定的类型中搜索，如 event 类型。
Elasticsearch 也允许每次在多种类型中搜索，甚至是在搜索时仅仅指定索引的名称，这样就可以在某个索引的所有类型中搜索。

上图中，当我们在 get-together 这个索引中搜索的时候，返回的结果同时有 group 和 event 类型。
当我们在 get-together 这个索引的 event 分组中搜索的时候，返回的结果只包含了 event 分组的结果。


## 检索和定义映射

当学习 Elasticsearch 的时候，通常不用担心映射，因为 Elasticsearch 会自动识别字段，并相应地调整映射。
在一个生产应用中，你常常想预先定义自己地映射，这样就没有必要依赖于自动的字段识别。


### 获取目前的映射

为了查看某个字段类型当前的映射，向该类型 URL 的 _mapping 接口发送一个 HTTP GET 请求:

```
curl 'localhost:9200/get-together/group/_mapping?pretty'
```

首先索引一个来自聚会网站的新文档，指定一个名为 new-events 的类型，然后 Elasticsearch 会自动地创建映射。
接着，检索创建的映射，结果展示了文档的字段，以及 Elasticsearch 为每个字段所识别的字段类型。

创建文档，索引一篇新的文档

```
curl -XPUT 'localhost:9200/get-together/new-events/1' -d '{
    "name": "Late Night with Elasticsearch",
    "date": "2013-10-25T19:00"
}'
```

输出：

```
{
    "_index": "get-together",
    "_type": "new-events",
    "_id": "1",
    "_version": 1,
    "result": "created",
    "_shards": {
        "total": 2,
        "successful": 1,
        "failed": 0
    },
    "_seq_no": 0,
    "_primary_term": 1
}
```

获取当前映射

```
curl 'localhost:9200/get-together/_mapping?pretty'
```

输出：

```
{
  "get-together": {
    "mappings": {
      "properties": {
        "date": {
          "type": "date"
        },
        "name": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        }
      }
    }
  }
}
```


### 定义新的映射

为了定义一个映射，可以使用和前面一样的 URL，但是应该发送一个 HTTP PUT 请求而不是 GET 请求。
需要在请求中指定 JSON 格式的映射，格式和获取的映射相同。
例如，下面的请求设置了一个映射，其中将 host 字段定义为 string 类型：

```
curl -XPUT 'localhost:9200/get-together/_mapping' -d '{
    "new-events": {
        "properties": {
            "host": {
                "type": "string"
            }
        }
    }
}'
```

可以在创建索引之后，向某类型中插入任何文档之前定义一个新的映射。


## 扩展现有映射

如果在现有的基础上再设置一个映射，Elasticsearch 会将两者进行合并。

```
{
  "get-together": {
    "mappings": {
      "properties": {
        "date": {
          "type": "date"
        },
        "host": {
          "type": "text"
        },
        "name": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        }
      }
    }
  }
}
```

这个映射目前含有两个来自初始映射的字段，外加一个新字段。随着新字段的加入，初始的映射被扩展了，在任何时候都可以进行这样的操作。
Elasticsearch 将此称为现有映射和先前提供的映射合并。

但是，并非所有的合并是奏效的。例如，你无法改变现有字段的数据类型，而且通常无法改变一个字段被索引的方式。

试图将现有的字段类型从字符串改变为长整型：

```
curl -XPUT 'localhost:9200/get-together/_mapping' -d '{
    "new-events": {
        "properties": {
            "host": {
                "type": long"
            }
    }
}'
```

报错 `MergeMappingException[Merge field with failures]`

避免这个错误的唯一方法是重新索引 new-events 里的所有数据，包括如下步骤：

(1) 将 new-events 类型里的所有数据移除。移除数据的同时也会移除映射

(2) 设置新的映射

(3) 再次索引所有的数据

为了理解为什么可能需要重新索引数据，想象一下已经索引了一个活动，host 字段是字符串。
如果现在希望将 host 字段变为 long，Elasticsearch 不得不改变 host 在现有文档中的索引方式。
编辑现存的文档意味着删除和再次索引。

正确的映射，理想情况下只需要增加，而无需修改。


## 用于定义文档字段的核心类型

Elasticsearch 中一个字段可以是核心类型之一，如字符串或者整型，也可以是一个从核心类型派生的复杂类型，如数组。

还有些其他的类型本章没有涉及。例如，嵌套类型允许在文档中包含其他文档，或 geo_point 类型存储了地球上的经度和纬度位置。

> 除了文档中定义的字段，如名称和日期，Elasticsearch 还使用一组预定义的字段来丰富文档。
> 例如，有一个 _all 字段，索引了文档中的所有字段。这对于用户未指定字段的搜索很有帮助，
> 他们可以在所有字段中搜索，这些预定义的字段有其自己的配置选项。

Elasticsearch 的核心字段类型：

|  核心类型 | 取值示例 |
|---|---|
|  字符串 |  "Lee", "Elasticsearch Denver" |
|  数值 |  17, 3.2 |
| 日期  |  2013-03-15T10:02:26.231+1:00 |
| 布尔  | 取值可以是 true 或 false |


### 字符串类型

字符串是最直接的：如果在索引字符，字段就应该是 string 类型。

解析文本、转变文本、将其分解未基本元素使得搜索更为相关，这个过程叫做分析。先看看基本原理：

```
curl -XPUT 'localhost:9200/get-together/new-events/1' -d '{
    "name": "Late Night with Elasticsearch",
    "date": "2013-10-25T19:00"
}'
```

当这篇文档索引后，在 name 字符串字段里搜索单词 late。

```
curl 'localhost:9200/get-together/new-events/_search?pretty' -d '{
    "query": {
        "query_string": {
            "query": "late"
        }
    }
}'
```

结果：

```
{
  "took": 126,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 1,
      "relation": "eq"
    },
    "max_score": 0.2876821,
    "hits": [
      {
        "_index": "get-together",
        "_type": "new-events",
        "_id": "1",
        "_score": 0.2876821,
        "_source": {
          "name": "Late Night with Elasticsearch",
          "date": "2013-10-25T19:00"
        }
      }
    ]
  }
}
```

Elasticsearch 通过分析连接了字符串 "late" 和 "Late Night with Elasticsearch"。如下图所示，
当索引 "Late Night with Elasticsearch" 时，默认的分析器将所有字符转化为小写，然后将字符串分解为单词。

![3-2](/images/es/3-2.png)

分析过程生成了 4 个词条，即 late、night、with 和 elasticsearch。查询的字符串经过同样的处理过程，
但是这次，"late" 生成了同样的字符串 -- "late"。因为查询生成的 late 词条和文档生成的 late 词条匹配了，
所以文档（doc1）匹配上了搜索。

> 定义：一个词条是文本中的一个单词，是搜索的基本单位。在不同的情境下，单词可以意味着不同的事务，例如，
> 它可以是一个名词，也可以是一个 IP 地址。如果只想严格匹配某个字段，应该将整个字段作为一个单词来对待。

另一方面，如果索引 "latenight"，默认的分析器只创建了一个词条 -- latenight。
搜索 "late" 不会命中 doc2 文档，因为它并不包含词条 late。

映射会对这种分析过程起到作用。可以在映射中指定许多分析的选项。例如，可以配置分析，
生成原始词条的同义词，这样同义词的查询同样可以匹配。

现在来看看 index 选项，它可以设置为 analyzed（默认）、not_analyzed 或 no。
例如，将 name 字段设置为 not_analyzed，映射可能看上去像这样:

```
curl -XPUT 'localhost:9200/get-together/_mapping/new-events' -d '{
    "new-events": {
        "properties": {
            "name": {
                "type": "string",
                "index": "not_analyzed"
            }
        }
    }
}'
```


默认情况下，index 被设置为 analyzed，并产生了之前看到的行为：分析器将所有字符转换为小写，并将字符串分解为单词。
当期望每个单词完整匹配时，请使用这种选项。举个例子，如果用户搜索 "elasticsearch"，他们希望在结果列表里看到
"Late Night with Elasticsearch"。

将 index 设置为 not_analyzed，将会产生相反的行为：分析过程被略过，整个字符串被当作单独的词条进行索引。
当进行精准的匹配时，请使用这个选项，如搜索标签。
你可能希望 "big data" 出现在搜索 "big data" 的结果中，而不是出现在搜索 "data" 的结果中。
同样，对于多数的词条计数聚集，也需要这个。如果想知道最常出现的标签，可能需要 "big data" 作为一整个词条统计，
而不是 "big" 和 "data" 分开统计。

如果将 index 设置为 no，索引就被略过了也没有词条产生，因此无法在那个字段上进行搜索。
当无须在这个字段上搜索时，这个选项节省了存储空间，也缩短了索引和搜索的时间。
例如，可以存储活动的评论。尽管存储和展示这些评论是很有价值的，但是可能并不需要搜索它们。
在这种情况下，关闭那个字段的索引，使得索引的过程更快，并节省了存储空间。


### 在搜索未经过分析的字段时，检查你的查询是否被分析过

对于某些查询，如之前使用的 query_string，分析过程是运用于搜索条件的。了解这种情况是否发生是非常重要的，否则可能产生无法预料的结果。

例如，如果索引 "Elasticsearch" 而它又没有被分析过，系统就会生成词条 "Elasticsearch"。
像这样查询 "Elasticsearch" 的时候：

```
curl 'localhost:9200/get-together/new-events/_search?q=Elasticsearch'
```

URI 请求被分析之后，词条 elasticsearch(小写) 就会生成。但是索引中并没有词条 elasticsearch。
你只有 Elasticsearch（首字母 E 大写），于是不会命中结果。
